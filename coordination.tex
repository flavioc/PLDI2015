The original Meld was
implemented as an ensemble programming language, targeting modular robotic systems such as
Claytronics~\cite{ashley-rollman-derosa-iros07wksp}. In such systems, there is a natural matching
between computation and processing units, since each robot is represented by a node. This distribution
of data leaves little choice to be made in the division of computation to the various nodes.

On the other hand, LM has no natural matching of data and computation to workers (processes, threads),
since nodes are a program abstraction and part of the program's logic.
We view the set of nodes as a graph data structure where workers will perform work.
A worker is able to process any node, although a node cannot be computed by more than one worker
at the same time. This disallows the manipulation of a node by multiple workers.

Since LM uses linear logic, the order in which nodes are scheduled can impact the
performance and even the results of the program. When only using
classical logic, no matter how computation is done, the end result will be the same since the program
is strictly monotonic.
LM introduces the concept of \emph{coordination} that allows the programmer
to write code that changes how the runtime system schedules nodes.

Randomized and approximation
algorithms can obtain significant benefits from coordination directives because although the final
program results will not be exact, they follow important statistical properties and can be computed faster.
Examples of such programs are PageRank~\cite{Lubachevsky:1986:CAA:4904.4801} and
Loopy Belief Propagation~\cite{Gonzalez+al:aistats09paraml}.

\subsection{Scheduling Facts}

We can use action facts to change the order in which nodes are evaluated by adding
\emph{priorities}. Node priority works at the worker level
so that each worker can make a local decision about which node of the graph to run next.
Note that, by default, nodes are picked arbitrarily (a FIFO approach is used).

The following list presents the action facts available to manipulate the scheduling decisions of the system:

\begin{description}
   \item[\texttt{type linear action set-priority(node, float)}]: This sets the priority of a node. If the node already has some priority, we only change the priority if the new one is higher priority. The programmer can decide if priorities are to be ordered in ascending or descending order.
   \item[\texttt{type linear action add-priority(node, float)}]: This gets the current node's priority and increases or decreases it.
   \item[\texttt{type linear action schedule-next(node)}]: The work will fetch the highest priority node's priority $P$ from its set of nodes and set the action's argument node's priority as $P + 1.0$. If using the priorities
   in ascending order, we pick the lowest priority and subtract $1.0$.
   \item[\texttt{type linear action unset-priority(node)}]: Removes the priority, if any, of a given node.
   \item[\texttt{type linear action stop-program(node)}]: Immediately stops the execution of the whole program.
\end{description}

When the highest priority node is picked up for execution, its priority is reset to 0 (the default priority value). This means that
the programmer must set the node's priority again if he wants to prioritize that node.

We intend to add more action facts in the near future. For example, we want the programmer to be able to place specific nodes in workers. This will permit good use of
memory locality by forcing certain computations to be performed in the same worker.

Sensing facts provide information about node placement and node priority. We can use those facts
to express coordination policies. LM provides the following two
sensing facts:

\begin{description}
   \item[\texttt{type linear cpu-id(node, node, int)}]: The third argument indicates the worker's ID where the node of the second argument is currently running.
   \item[\texttt{type linear priority(node, node, float)}]: The third argument is the current priority of the node in the second argument.
\end{description}

Note that when sensing facts are consumed, they are re-derived automatically, except if the programmer explicitly tells the compiler otherwise. 

\subsubsection{Global Directives}

We also provide a few global coordination statements:

\begin{description}
   \item[\texttt{priority @order ORDER.}] \texttt{ORDER} can be either \texttt{asc} or \texttt{desc}. This defines if node's are to be selected by the smallest or the greatest priority, respectively.
   \item[\texttt{priority @initial P.}] The \texttt{initial} statement informs the runtime system that all nodes must start with priority $P$. Alternatively, the programmer can define an \texttt{set-priority(A, P)} axiom.
   \item[\texttt{priority @static.}] The \texttt{static} priority tells the runtime system that the partition of nodes among workers is to be used until the end of program. 
\end{description}

