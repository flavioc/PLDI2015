Since LM uses linear logic and supports deletion of facts, the order in which
nodes are scheduled can impact the performance and even the results of the
program.

The SSSP program present in Fig.~\ref{code:shortest_path_program} is concise and
declarative but its performance may depend in the order in which nodes are
executed. If nodes with greater distances are prioritized over other nodes, the
program will generate more \texttt{relax} facts since it will take longer to
reach the shortest distances. From Fig.~\ref{fig:shortest_path_program}, it is
clear that the best computational ordering is the following: \texttt{@1},
\texttt{@3}, \texttt{@2} and then \texttt{@4}, where only 4 \texttt{relax}
facts are generated. If we had decided to process nodes in order
\texttt{@1}, \texttt{@2}, \texttt{@4}, \texttt{@3}, \texttt{@4},
\texttt{@2}, then 6 \texttt{relax} facts would have been generated.
Therefore, the optimal solution for SSSP is to schedule the node with the
shortest distance, which is essentially the Dijkstra shortest path
algorithm~\cite{Dijkstra}. Note how it is possible to change the nature of
the algorithm by simply changing the order of node computation, but still
retain the declarative nature of the program.

We introduce the concept of \emph{coordination facts} that allow the programmer
to change how the run time schedules nodes and partitions the nodes among
threads of execution. Coordination facts can be used in the body or head of the
rules to allow the programmer to reason and change how execution is to be done.
In this fashion, we keep the language declaratively because we reason logically
about the state of execution, without the need to introduce extra-logical
operators into the language that would reduce problems when attempting to prove
properties about programs.

There are two kinds of coordination facts. The first kind of coordination facts are
called \emph{sensing facts} and are used to sense information about data
placement (where is the node being executed) or scheduled (what is the priority
of the node). The second kind of coordination facts are \emph{action facts} that,
when derived, are consumed to apply a coordination operation during execution.
These logical rules that use coordination are implemented efficiently in the run
time system and are hidden from the programmer.

\subsection{Scheduling Facts}

We can use action facts to change the order in which nodes are evaluated by adding
\emph{priorities}. Node priority works at the thread level
so that each thread can make a local decision about which node of the graph to run next.
Note that, by default, nodes are picked arbitrarily (a FIFO approach is used).

We have two kinds of priorities: a \emph{temporary priority} and a \emph{default
priority}. A default priority is used indefinitely, while a temporary priority
is only used once, so that when node with a temporary priority $P$ is picked to
run, the priority will default back to $D$, the default priority. Initially,
all nodes have a default priority of $0$.

The following list presents the action facts available to manipulate the scheduling
decisions of the system:

\begin{itemize}
   \item \texttt{type linear set-priority(node, float)}: This sets the
   temporary priority of a node. If the node already has a priority, we only
   change the priority if the new one is higher priority. The programmer can
   decide if priorities are to be ordered in ascending or descending order.
   \item \texttt{type linear action add-priority(node, float)}: Increments,
   temporarily, the current priority of the node.
   \item\texttt{type linear schedule-next(node)}: The work will fetch the
   highest priority node's priority $P$ from its set of nodes and set the
   action's argument node's priority as $P + 1.0$. If using the priorities in
   ascending order, we pick the lowest priority and subtract $1.0$.
   \item\texttt{type linear set-default-priority(node, float)}: Sets the default
   priority of the node.
   \item \texttt{type linear action stop-program(node)}: Immediately stops the
   execution of the whole program.
\end{itemize}

LM provides the sensing fact \texttt{type linear priority(node, node, float)},
where the second argument is the target node and the third argument is the
node priority. Sensing facts are only used in the body of the rules in order
to fetch information from the runtime system.
Note that when sensing facts are consumed, they are re-derived automatically,
except if the programmer explicitly tells the compiler otherwise. 
Logically, \texttt{set-priority} and \texttt{set-default-priority} update the
value of \texttt{priority} facts, but this done seamlessly by the runtime
system.

\subsubsection{Partitioning facts}

We provide several coordination facts for dealing with node partitioning among
the available threads executing the program. In terms of action
facts, we have the following:

\begin{itemize}
   \item \texttt{type linear set-cpu(node, int)}: Moves the node to a
   thread of execution.
   \item \texttt{type linear set-affinity(node, node)}: Places the first node in
   the same thread as the second node.
   \item \texttt{type linear set-moving(node)}: Allows the node to move freely
   between threads.
   \item \texttt{type linear set-static(node)}: Forces the node to stay in the
   same thread indefinitely.
\end{itemize}

For sensing facts, we have the following set of coordination facts:

\begin{itemize}
   \item \texttt{type linear cpu-id(node, node, int)}: The third argument
   indicates the thread where the node of the second argument is currently running.
   \item \texttt{type linear moving(node, node)}: Fact available if the node in the
   second argument is allowed to move between threads.
   \item \texttt{type linear static(node, node)}: Fact available if the node in
   the second argument is not allowed to move between threads.
\end{itemize}

\iffalse
\subsubsection{Global Directives}

We also provide a few global coordination statements:

\begin{description}
   \item[\texttt{priority @order ORDER.}] \texttt{ORDER} can be either \texttt{asc} or \texttt{desc}. This defines if node's are to be selected by the smallest or the greatest priority, respectively.
   \item[\texttt{priority @initial P.}] The \texttt{initial} statement informs the runtime system that all nodes must start with priority $P$. Alternatively, the programmer can define an \texttt{set-priority(A, P)} axiom.
   \item[\texttt{priority @static.}] The \texttt{static} priority tells the runtime system that the partition of nodes among workers is to be used until the end of program. 
\end{description}

\fi
