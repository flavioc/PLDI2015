Randomized and approximation algorithms can obtain significant benefits from
coordination directives because although the final program results will not be
exact, they follow important statistical properties and can be computed faster.
Examples of such programs are Loopy Belief Propagation.
Loopy Belief Propagation~\cite{Murphy99loopybelief} (LBP) is an approximate inference algorithm
used in graphical models with cycles. In its essence, LBP is a sum-product message passing algorithm
where nodes exchange messages with their immediate neighbors and apply some computations to the messages
received.

LBP is an algorithm that maps very well to the graph based model of LM. In its
original form, the belief values of nodes are computed by synchronous iterations.
LBP offers more concurrency when belief values are computed asynchronously
leading to faster convergence. For this, every node keeps track of all messages
sent/received and recomputes the belief using partial information from neighbor
nodes. It is then possible to prioritize the computation of beliefs when a
neighbor's belief changes significantly.

The asynchronous approach proves to be a nice improvement over the synchronous
version. Still, it is possible to do even better. Gonzalez et
al~\cite{Gonzalez+al:aistats09paraml} developed an optimal algorithm to compute
this algorithm by first building a tree and then updating the beliefs of each
node twice, first from the leaves to the root and then from the root to the
leaves. The root of this tree is the node with the highest priority (based on
belief) while the other nodes in the tree must have a non-zero priority.
Note that the priorities are updated whenever a neighbor updates their belief.
These \emph{splash trees} are built iteratively until we reach convergence.
In Fig.~\ref{splash_bp} we represent two threads creating two different splash
trees. It is encouraged to create several splash trees concurrently as long as
we have threads to create them.

\begin{topfig}
   \begin{center}
      \includegraphics[width=6.5cm]{figures/splash_bp}
   \end{center}
   \scap{splash_bp}{Creating splash trees for belief propagation. Each threads picks the
   highest priority node and creates a tree from that node. The belief values
   are updated in two phases: first from the leaves to the root and then from
   the root to the leaves.}
\end{topfig}


The code for Splash Belief Propagation~(SBP) in Fig.~\ref{code:sbp} presents the
coordination code for LBP.  Please note that we just appended the code in
Fig.~\ref{code:sbp} to a working but unoptimized version of the algorithm, every
other logical rule remains the same. We add new logical ruels that coordinate
the creation and execution of the splash trees:

\begin{description}
   \item[Tree building]: Each node has a \texttt{inactive} fact that is used to
   start the tree building process. When the highest priority node is picked, a
   \texttt{tree} is created that will navigate through the tree. In lines 15-21,
   we use an \emph{aggregate}~\cite{cruz-iclp14} to gather all the neighbor
   nodes that have a positive priority (due to a new belief update) and are in the
   same thread. Nodes are collected into list \texttt{L} (line 21) and
   appended to list \texttt{Next}.
   
   \item[First phase]: In the
   third rule (lines 11-12), when the number of nodes of the tree reaches a
   certain limit, a \texttt{first-phase} is generated to update the beliefs of
   all nodes in the tree, starting from the leaves and ending at the root As the
   nodes are updated, an \texttt{update} fact is derived to update the belief
   values (line 35).

   \item[Second phase]: In the second phase, the computation of beliefs is
   performed from the root to the leaves and the belief values are updated a
   second time (line 42).
\end{description}

Note that the \texttt{set-static} and \texttt{set-cpu} action fact are used in
line 2 in order to (1) force nodes to stay in the thread and (2) to partition
nodes as a grid of threads. This setups a well defined area of nodes
for threads to build splash trees on.

\begin{topfig}
\scriptsize\begin{Verbatim}[numbers=left,commandchars=*\{\}]
!coord(A, X, Y), start(A)
   -o *underline{set-static(A), set-cpu(A, grid(X, Y))}.

// TREE BUILDING
// expand tree by adding neighbor nodes
inactive(A), tree(A, All, Next) -o expand-tree(A, All, Next).
// start tree since we do not have one
inactive(A), *underline{@priority(A, A, P)}, P > 0.0
   -o expand-tree(A, [A], [A]).
// end tree building
expand-tree(A, All, Next), length(All) >= maxnodes
   -o first-phase(A, All, reverse(All)).
// expand tree
expand-tree(A, All, [A | Next]), length([A | Next]) < maxnodes
   -o [collect => L | Side | !edge(A, L, Side),
         0 = count(All, L), // L is not in All
         0 = count(Next, L), // L is not in Next
         *underline{@priority(A, L, P), P > 0.0,}
         *underline{@cpu-id(A, L, Id1)},
         *underline{@cpu-id(A, A, Id2), Id1 = Id2} |
         send-tree(A, All, Next ++ L)].

send-tree(A, All, [])
   -o first-phase(A, All, reverse(All)).
send-tree(A, All, [B | Next])
   -o *underline{schedule-next(B)},
      tree(B, All ++ [B], [B | Next]).

// FIRST PHASE
first-phase(A, [A], [A]) -o second-phase(A, [], A).
first-phase(A, [A, B | Next], [A])
   -o update(A), *underline{schedule-next(B)},
      second-phase(B, [B | Next], A).
first-phase(A, All, [A, B | Next])
   -o update(A), *underline{schedule-next(B)},
      first-phase(B, All, [B | Next]).

// SECOND PHASE
second-phase(A, [], _)
   -o *underline{set-priority(A, 0.0)}, inactive(A), update(A).
second-phase(A, [A], Back)
   -o update(A), inactive(Back),
      inactive(A), *underline{set-priority(A, 0.0)}.
second-phase(A, [A, B | Next], Back)
   -o update(A), inactive(Back), *underline{schedule-next(B)},
      second-phase(B, [B | Next], A).
\end{Verbatim}
  \scap{code:sbp}{Coordination code for the Splash Belief Propagation program. LM needs
     50 lines of rules to implement splash trees, while GraphLab needs a
     total of 350 lines of C++ to implement the same functionality.  Note
     that when a linear fact is prefixed by \texttt{@}, it indicates that the
     fact is going to be re-derived.}
\end{topfig}
\normalsize

\begin{dblfig}
   \begin{center}
      \subfloat[]{\includegraphics[width=5cm]{results/system_belief-propagation-400.png}}
      \subfloat[]{\includegraphics[width=5cm]{results/system_splash-bp-400.png}}
      \subfloat[]{\includegraphics[width=5cm]{results/system_improve_belief-propagation-400.png}}
   \end{center}
   \scap{results:splash_bp}{Experimental results for LBP and SBP. Figure (a) shows the
      scalability of LBP for both LM and GraphLab and Figure (b) shows the
      scalability of SBP. Figure (c) presents the
      improvements seen in SBP against LBP, where SBP runs, on average, 1.5 to 2.5
      times faster than LBP.}
\end{dblfig}


In this program, coordination assumes a far more important role than we have
seen before. Coordination rules fully drive the behavior of the algorithm and
although the final result of the algorithm is identical to the original
algorithm (minus probabilitistic errors), SBP works in a very different way.
A system that also implements SBP is
GraphLab~\cite{GraphLab2010}, a C++ framework for writing machine algorithms.
GraphLab provides the splash scheduler for these types of inferences as part of
the framework. This particular scheduler is around 350 lines of complicated C++ code.
With our coordination facts, it is possible to create fairly complicated coordination
patterns with only 12 simple logical rules.

We measured the behavior of LBP and SBP for both LM and GraphLab.
Fig.~\ref{results:splash_bp} shows that both systems have very similar behavior
when using a variable number of threads.
Note that GraphLab avoids message passing between nodes since new neighbor
belief updates are changed immediatelly, resulting in slightly better
scalability for GraphLab.

